<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Interactive Learning - Blockly</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/JSCPP@2.0.6/dist/JSCPP.es5.min.js"></script>
    <style>
        .blockly-ws {
            height: calc(100vh - 56px);
        }
        
        @media (min-width: 640px) {
            .blockly-ws {
                height: calc(100vh - 80px);
            }
        }
        .code-output {
            font-family: 'Courier New', monospace;
        }
        .modal-backdrop {
            backdrop-filter: blur(4px);
        }
        .input-prompt {
            background: #1a1a1a;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .input-prompt:focus {
            outline: none;
            box-shadow: 0 0 5px #00ff00;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <!-- Navigation Bar -->
    <nav class="bg-white shadow-lg border-b-2 border-indigo-200">
        <div class="max-w-7xl mx-auto px-2 sm:px-4">
            <div class="flex justify-between items-center h-14 sm:h-16">
                <div class="flex items-center space-x-2 sm:space-x-4">
                    <h1 class="text-lg sm:text-2xl font-bold text-indigo-700">C++ Studio</h1>
                    <span class="hidden sm:inline text-sm text-gray-500">Visual Programming</span>
                </div>
                <div class="flex items-center space-x-1 sm:space-x-3">
                    <button id="addBlockBtn" class="bg-green-500 hover:bg-green-600 text-white px-2 sm:px-4 py-2 rounded-lg font-medium transition-colors duration-200 flex items-center space-x-1 sm:space-x-2 text-sm">
                        <span>‚ûï</span>
                        <span class="hidden sm:inline">Add</span>
                    </button>
                    <button id="quickTemplateBtn" class="bg-purple-500 hover:bg-purple-600 text-white px-2 sm:px-4 py-2 rounded-lg font-medium transition-colors duration-200 flex items-center justify-center text-sm">
                        <span>‚ö°</span>
                    </button>
                    <button id="clearBtn" class="bg-red-500 hover:bg-red-600 text-white px-2 sm:px-4 py-2 rounded-lg font-medium transition-colors duration-200 flex items-center space-x-1 sm:space-x-2 text-sm">
                        <span>üóëÔ∏è</span>
                        <span class="hidden sm:inline">Clear</span>
                    </button>
                    <button id="runBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 sm:px-6 py-2 rounded-lg font-medium transition-colors duration-200 flex items-center space-x-1 sm:space-x-2 text-sm">
                        <span>‚ñ∂Ô∏è</span>
                        <span>Run</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Workspace -->
    <div id="workspace" class="blockly-ws"></div>

    <!-- Block Selection Modal -->
    <div id="blockModal" class="fixed inset-0 bg-black bg-opacity-50 modal-backdrop hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-2 sm:p-4">
            <div class="bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[80vh] overflow-y-auto">
                <div class="p-4 sm:p-6 border-b border-gray-200">
                    <div class="flex justify-between items-center">
                        <h2 class="text-lg sm:text-2xl font-bold text-gray-800">Pilih Blok C++</h2>
                        <button id="closeModal" class="text-gray-500 hover:text-gray-700 text-xl sm:text-2xl">‚úï</button>
                    </div>
                </div>
                <div class="p-3 sm:p-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-6">
                    <!-- Basic Structure Category -->
                    <div class="bg-purple-50 p-3 sm:p-4 rounded-lg border border-purple-200">
                        <h3 class="font-bold text-purple-700 mb-2 sm:mb-3 text-sm sm:text-base">Struktur Dasar</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-purple-100 hover:bg-purple-200 rounded text-xs sm:text-sm" data-type="include">Include Library</button>
                            <button class="block-btn w-full text-left p-2 bg-purple-100 hover:bg-purple-200 rounded text-xs sm:text-sm" data-type="namespace">Using Namespace</button>
                            <button class="block-btn w-full text-left p-2 bg-purple-100 hover:bg-purple-200 rounded text-xs sm:text-sm" data-type="main">Fungsi main()</button>
                        </div>
                    </div>

                    <!-- Input/Output Category -->
                    <div class="bg-blue-50 p-3 sm:p-4 rounded-lg border border-blue-200">
                        <h3 class="font-bold text-blue-700 mb-2 sm:mb-3 text-sm sm:text-base">Input & Output</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-blue-100 hover:bg-blue-200 rounded text-xs sm:text-sm" data-type="cout">Output (cout)</button>
                            <button class="block-btn w-full text-left p-2 bg-blue-100 hover:bg-blue-200 rounded text-xs sm:text-sm" data-type="cin">Input (cin)</button>
                            <button class="block-btn w-full text-left p-2 bg-blue-100 hover:bg-blue-200 rounded text-xs sm:text-sm" data-type="stream">Stream Operator</button>
                        </div>
                    </div>

                    <!-- Variables Category -->
                    <div class="bg-green-50 p-3 sm:p-4 rounded-lg border border-green-200">
                        <h3 class="font-bold text-green-700 mb-2 sm:mb-3 text-sm sm:text-base">Variabel</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-green-100 hover:bg-green-200 rounded text-xs sm:text-sm" data-type="declare_var">Buat Variabel</button>
                            <button class="block-btn w-full text-left p-2 bg-green-100 hover:bg-green-200 rounded text-xs sm:text-sm" data-type="set_var">Ubah Nilai Variabel</button>
                            <button class="block-btn w-full text-left p-2 bg-green-100 hover:bg-green-200 rounded text-xs sm:text-sm" data-type="get_var">Ambil Nilai Variabel</button>
                        </div>
                    </div>

                    <!-- Data Types Category -->
                    <div class="bg-yellow-50 p-3 sm:p-4 rounded-lg border border-yellow-200">
                        <h3 class="font-bold text-yellow-700 mb-2 sm:mb-3 text-sm sm:text-base">Tipe Data</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-yellow-100 hover:bg-yellow-200 rounded text-xs sm:text-sm" data-type="text">Text</button>
                            <button class="block-btn w-full text-left p-2 bg-yellow-100 hover:bg-yellow-200 rounded text-xs sm:text-sm" data-type="number">Angka</button>
                            <button class="block-btn w-full text-left p-2 bg-yellow-100 hover:bg-yellow-200 rounded text-xs sm:text-sm" data-type="boolean">Logika (true/false)</button>
                        </div>
                    </div>

                    <!-- Math Operations Category -->
                    <div class="bg-red-50 p-3 sm:p-4 rounded-lg border border-red-200">
                        <h3 class="font-bold text-red-700 mb-2 sm:mb-3 text-sm sm:text-base">Operasi Matematika</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-red-100 hover:bg-red-200 rounded text-xs sm:text-sm" data-type="math_op">Operasi (+, -, *, /, %)</button>
                        </div>
                    </div>

                    <!-- Logic Operations Category -->
                    <div class="bg-indigo-50 p-3 sm:p-4 rounded-lg border border-indigo-200">
                        <h3 class="font-bold text-indigo-700 mb-2 sm:mb-3 text-sm sm:text-base">Operasi Logika</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-indigo-100 hover:bg-indigo-200 rounded text-xs sm:text-sm" data-type="compare_op">Perbandingan</button>
                            <button class="block-btn w-full text-left p-2 bg-indigo-100 hover:bg-indigo-200 rounded text-xs sm:text-sm" data-type="logical_op">Logika (&&, ||)</button>
                            <button class="block-btn w-full text-left p-2 bg-indigo-100 hover:bg-indigo-200 rounded text-xs sm:text-sm" data-type="not_op">Negasi (!)</button>
                        </div>
                    </div>

                    <!-- Control Flow Category -->
                    <div class="bg-pink-50 p-3 sm:p-4 rounded-lg border border-pink-200">
                        <h3 class="font-bold text-pink-700 mb-2 sm:mb-3 text-sm sm:text-base">Kontrol Alur</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-pink-100 hover:bg-pink-200 rounded text-xs sm:text-sm" data-type="if">If Statement</button>
                            <button class="block-btn w-full text-left p-2 bg-pink-100 hover:bg-pink-200 rounded text-xs sm:text-sm" data-type="if_else">If-Else Statement</button>
                        </div>
                    </div>

                    <!-- Loops Category -->
                    <div class="bg-teal-50 p-3 sm:p-4 rounded-lg border border-teal-200">
                        <h3 class="font-bold text-teal-700 mb-2 sm:mb-3 text-sm sm:text-base">Pengulangan</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-teal-100 hover:bg-teal-200 rounded text-xs sm:text-sm" data-type="for_loop">For Loop</button>
                            <button class="block-btn w-full text-left p-2 bg-teal-100 hover:bg-teal-200 rounded text-xs sm:text-sm" data-type="while_loop">While Loop</button>
                        </div>
                    </div>

                    <!-- Comments Category -->
                    <div class="bg-gray-50 p-3 sm:p-4 rounded-lg border border-gray-200">
                        <h3 class="font-bold text-gray-700 mb-2 sm:mb-3 text-sm sm:text-base">Komentar</h3>
                        <div class="space-y-1 sm:space-y-2">
                            <button class="block-btn w-full text-left p-2 bg-gray-100 hover:bg-gray-200 rounded text-xs sm:text-sm" data-type="comment">Komentar (//)</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quick Templates Modal -->
    <div id="templateModal" class="fixed inset-0 bg-black bg-opacity-50 modal-backdrop hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-2 sm:p-4">
            <div class="bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[80vh] overflow-y-auto">
                <div class="p-4 sm:p-6 border-b border-gray-200">
                    <div class="flex justify-between items-center">
                        <h2 class="text-lg sm:text-2xl font-bold text-gray-800">Template Cepat C++</h2>
                        <button id="closeTemplateModal" class="text-gray-500 hover:text-gray-700 text-xl sm:text-2xl">‚úï</button>
                    </div>
                </div>
                <div class="p-3 sm:p-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-6">
                    <!-- Hello World Template -->
                    <div class="bg-gradient-to-br from-blue-50 to-blue-100 p-4 sm:p-6 rounded-lg border border-blue-200 hover:shadow-lg transition-shadow cursor-pointer" data-template="hello-world">
                        <div class="text-center mb-3 sm:mb-4">
                            <div class="text-3xl sm:text-4xl mb-2">üëã</div>
                            <h3 class="font-bold text-blue-700 text-base sm:text-lg">Hello World</h3>
                        </div>
                        <p class="text-xs sm:text-sm text-gray-600 mb-3 sm:mb-4">Program dasar yang menampilkan "Hello World" ke layar.</p>
                        <div class="bg-white p-2 sm:p-3 rounded text-xs font-mono text-gray-700">
                            #include &lt;iostream&gt;<br>
                            using namespace std;<br>
                            int main() {<br>
                            &nbsp;&nbsp;cout &lt;&lt; "Hello World";<br>
                            &nbsp;&nbsp;return 0;<br>
                            }
                        </div>
                    </div>

                    <!-- Calculator Template -->
                    <div class="bg-gradient-to-br from-green-50 to-green-100 p-4 sm:p-6 rounded-lg border border-green-200 hover:shadow-lg transition-shadow cursor-pointer" data-template="calculator">
                        <div class="text-center mb-3 sm:mb-4">
                            <div class="text-3xl sm:text-4xl mb-2">üßÆ</div>
                            <h3 class="font-bold text-green-700 text-base sm:text-lg">Kalkulator Sederhana</h3>
                        </div>
                        <p class="text-xs sm:text-sm text-gray-600 mb-3 sm:mb-4">Program kalkulator dengan input dari user dan operasi matematika.</p>
                        <div class="bg-white p-2 sm:p-3 rounded text-xs font-mono text-gray-700">
                            Input dua angka<br>
                            Operasi: +, -, *, /<br>
                            Tampilkan hasil
                        </div>
                    </div>

                    <!-- Loop Example Template -->
                    <div class="bg-gradient-to-br from-purple-50 to-purple-100 p-4 sm:p-6 rounded-lg border border-purple-200 hover:shadow-lg transition-shadow cursor-pointer" data-template="loop-example">
                        <div class="text-center mb-3 sm:mb-4">
                            <div class="text-3xl sm:text-4xl mb-2">üîÑ</div>
                            <h3 class="font-bold text-purple-700 text-base sm:text-lg">Contoh Loop</h3>
                        </div>
                        <p class="text-xs sm:text-sm text-gray-600 mb-3 sm:mb-4">Program yang mendemonstrasikan penggunaan for loop dan if statement.</p>
                        <div class="bg-white p-2 sm:p-3 rounded text-xs font-mono text-gray-700">
                            For loop 1-10<br>
                            If genap/ganjil<br>
                            Tampilkan hasil
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Code Output Modal -->
    <div id="codeModal" class="fixed inset-0 bg-white hidden z-50">
        <div class="h-full flex flex-col">
            <div class="p-4 sm:p-6 border-b border-gray-200 bg-white">
                <div class="flex justify-between items-center">
                    <h2 class="text-lg sm:text-2xl font-bold text-gray-800">Hasil Kode C++</h2>
                    <button id="closeCodeModal" class="text-gray-500 hover:text-gray-700 text-xl sm:text-2xl bg-gray-100 hover:bg-gray-200 rounded-full w-8 h-8 sm:w-10 sm:h-10 flex items-center justify-center">‚úï</button>
                </div>
            </div>
            <!-- Mobile Layout: Output on top, Code on bottom -->
            <div class="flex flex-col lg:flex-row flex-1 overflow-hidden">
                <!-- Output Section (First on mobile, Second on desktop) -->
                <div class="w-full lg:w-1/2 p-3 sm:p-6 lg:border-r border-gray-200 flex flex-col order-1 lg:order-2">
                    <div class="flex items-center justify-between mb-2 sm:mb-3">
                        <h3 class="text-base sm:text-lg font-semibold text-gray-700">Output Program:</h3>
                        <div id="executionMode" class="text-xs px-2 py-1 rounded bg-blue-100 text-blue-700">
                            Mode: Checking...
                        </div>
                    </div>
                    <div id="programOutput" class="bg-black text-green-400 p-3 sm:p-4 rounded-lg text-xs sm:text-sm overflow-auto flex-1 font-mono whitespace-pre-wrap min-h-[200px] lg:min-h-0"></div>
                </div>
                <!-- Code Section (Second on mobile, First on desktop) -->
                <div class="w-full lg:w-1/2 p-3 sm:p-6 border-t lg:border-t-0 border-gray-200 flex flex-col order-2 lg:order-1">
                    <h3 class="text-base sm:text-lg font-semibold mb-2 sm:mb-3 text-gray-700">Kode C++:</h3>
                    <pre id="generatedCode" class="code-output bg-gray-100 p-3 sm:p-4 rounded-lg text-xs sm:text-sm overflow-auto flex-1 border min-h-[200px] lg:min-h-0"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Input Modal for cin operations -->
    <div id="inputModal" class="fixed inset-0 bg-black bg-opacity-50 modal-backdrop hidden z-60">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-xl shadow-2xl max-w-md w-full mx-4">
                <div class="p-4 sm:p-6 border-b border-gray-200">
                    <h3 class="text-base sm:text-lg font-semibold text-gray-800">Input Diperlukan</h3>
                </div>
                <div class="p-4 sm:p-6">
                    <p id="inputPrompt" class="text-sm sm:text-base text-gray-600 mb-3 sm:mb-4">Masukkan nilai untuk variabel:</p>
                    <input type="text" id="userInput" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm sm:text-base" placeholder="Ketik nilai di sini...">
                    <div class="flex justify-end space-x-3 mt-4">
                        <button id="cancelInput" class="px-3 sm:px-4 py-2 text-sm sm:text-base text-gray-600 hover:text-gray-800">Batal</button>
                        <button id="submitInput" class="px-3 sm:px-4 py-2 text-sm sm:text-base bg-blue-600 text-white rounded-lg hover:bg-blue-700">OK</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Blockly workspace
        let workspace;
        
        // Global variables for input handling
        let inputQueue = [];
        let currentInputIndex = 0;
        let inputResolve = null;
        let programVariables = {};

        // Define custom blocks
        function defineBlocks() {
            // Include block
            Blockly.Blocks['cpp_include'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üìö #include <")
                        .appendField(new Blockly.FieldDropdown([
                            ["iostream", "iostream"],
                            ["string", "string"],
                            ["cmath", "cmath"],
                            ["vector", "vector"]
                        ]), "LIBRARY")
                        .appendField(">");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(270);
                    this.setTooltip("Menyertakan library C++");
                }
            };

            // Namespace block
            Blockly.Blocks['cpp_namespace'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üè∑Ô∏è using namespace std;");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(270);
                    this.setTooltip("Menggunakan namespace standar C++");
                }
            };

            // Main function block
            Blockly.Blocks['cpp_main'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üöÄ int main() {");
                    this.appendStatementInput("STATEMENTS")
                        .setCheck(null)
                        .appendField("    ");
                    this.appendDummyInput()
                        .appendField("    return 0;")
                        .appendField("}");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(270);
                    this.setTooltip("Fungsi utama program C++");
                }
            };

            // Cout block
            Blockly.Blocks['cpp_cout'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üì§ cout <<");
                    this.appendValueInput("VALUE")
                        .setCheck(null);
                    this.appendDummyInput()
                        .appendField("endl")
                        .appendField(new Blockly.FieldCheckbox("TRUE"), "ENDL")
                        .appendField(";");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(210);
                    this.setTooltip("Output text to screen with optional line break (endl)");
                    this.setInputsInline(true);
                }
            };

            // Cin block
            Blockly.Blocks['cpp_cin'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üì• cin >>")
                        .appendField(new Blockly.FieldTextInput("variable"), "VAR")
                        .appendField(";");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(210);
                    this.setTooltip("Input value from user to variable");
                }
            };

            // Stream operator block
            Blockly.Blocks['cpp_stream'] = {
                init: function() {
                    this.appendValueInput("LEFT")
                        .setCheck(null);
                    this.appendDummyInput()
                        .appendField("üîó")
                        .appendField(new Blockly.FieldDropdown([
                            ["<<", "<<"],
                            [">>", ">>"]
                        ]), "OP");
                    this.appendValueInput("RIGHT")
                        .setCheck(null);
                    this.setOutput(true, null);
                    this.setColour(210);
                    this.setInputsInline(true);
                    this.setTooltip("Stream operator for chaining input/output operations");
                }
            };

            // Variable declaration
            Blockly.Blocks['cpp_declare_var'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üì¶")
                        .appendField(new Blockly.FieldDropdown([
                            ["int", "int"],
                            ["double", "double"],
                            ["string", "string"],
                            ["bool", "bool"]
                        ]), "TYPE")
                        .appendField(new Blockly.FieldTextInput("variable"), "NAME")
                        .appendField("=");
                    this.appendValueInput("VALUE")
                        .setCheck(null);
                    this.appendDummyInput()
                        .appendField(";");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(120);
                    this.setInputsInline(true);
                    this.setTooltip("Create new variable with data type and initial value");
                }
            };

            // Variable assignment
            Blockly.Blocks['cpp_set_var'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üìù")
                        .appendField(new Blockly.FieldTextInput("variable"), "VAR")
                        .appendField("=");
                    this.appendValueInput("VALUE")
                        .setCheck(null);
                    this.appendDummyInput()
                        .appendField(";");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(120);
                    this.setInputsInline(true);
                    this.setTooltip("Change value of existing variable");
                }
            };

            // Get variable
            Blockly.Blocks['cpp_get_var'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üìä")
                        .appendField(new Blockly.FieldTextInput("variable"), "VAR");
                    this.setOutput(true, null);
                    this.setColour(120);
                    this.setTooltip("Get value from variable");
                }
            };

            // Text block
            Blockly.Blocks['cpp_text'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üìù \"")
                        .appendField(new Blockly.FieldTextInput("Hello World"), "TEXT")
                        .appendField("\"");
                    this.setOutput(true, "String");
                    this.setColour(60);
                    this.setTooltip("Text or string literal");
                }
            };

            // Number block
            Blockly.Blocks['cpp_number'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üî¢")
                        .appendField(new Blockly.FieldNumber(0), "NUM");
                    this.setOutput(true, "Number");
                    this.setColour(60);
                    this.setTooltip("Number (integer or decimal)");
                }
            };

            // Boolean block
            Blockly.Blocks['cpp_boolean'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("‚úÖ")
                        .appendField(new Blockly.FieldDropdown([
                            ["true", "true"],
                            ["false", "false"]
                        ]), "BOOL");
                    this.setOutput(true, "Boolean");
                    this.setColour(60);
                    this.setTooltip("Boolean value: true or false");
                }
            };

            // Math operation
            Blockly.Blocks['cpp_math'] = {
                init: function() {
                    this.appendValueInput("A")
                        .setCheck("Number");
                    this.appendDummyInput()
                        .appendField("üßÆ")
                        .appendField(new Blockly.FieldDropdown([
                            ["+", "+"],
                            ["-", "-"],
                            ["*", "*"],
                            ["/", "/"],
                            ["%", "%"]
                        ]), "OP");
                    this.appendValueInput("B")
                        .setCheck("Number");
                    this.setOutput(true, "Number");
                    this.setColour(230);
                    this.setInputsInline(true);
                    this.setTooltip("Basic math operations");
                }
            };

            // Comparison operation
            Blockly.Blocks['cpp_compare'] = {
                init: function() {
                    this.appendValueInput("A")
                        .setCheck(null);
                    this.appendDummyInput()
                        .appendField("‚öñÔ∏è")
                        .appendField(new Blockly.FieldDropdown([
                            ["==", "=="],
                            ["!=", "!="],
                            [">", ">"],
                            [">=", ">="],
                            ["<", "<"],
                            ["<=", "<="]
                        ]), "OP");
                    this.appendValueInput("B")
                        .setCheck(null);
                    this.setOutput(true, "Boolean");
                    this.setColour(230);
                    this.setInputsInline(true);
                    this.setTooltip("Compare two values");
                }
            };

            // Logical operation (AND/OR)
            Blockly.Blocks['cpp_logical'] = {
                init: function() {
                    this.appendValueInput("A")
                        .setCheck("Boolean");
                    this.appendDummyInput()
                        .appendField("üîó")
                        .appendField(new Blockly.FieldDropdown([
                            ["&&", "&&"],
                            ["||", "||"]
                        ]), "OP");
                    this.appendValueInput("B")
                        .setCheck("Boolean");
                    this.setOutput(true, "Boolean");
                    this.setColour(230);
                    this.setInputsInline(true);
                    this.setTooltip("Logical AND (&&) or OR (||) operation");
                }
            };

            // Logical NOT operation
            Blockly.Blocks['cpp_not'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("‚ùå !");
                    this.appendValueInput("VALUE")
                        .setCheck("Boolean");
                    this.setOutput(true, "Boolean");
                    this.setColour(230);
                    this.setInputsInline(true);
                    this.setTooltip("Logical NOT operation - reverses true/false");
                }
            };

            // If statement
            Blockly.Blocks['cpp_if'] = {
                init: function() {
                    this.appendValueInput("CONDITION")
                        .setCheck("Boolean")
                        .appendField("ü§î if (");
                    this.appendDummyInput()
                        .appendField(") {");
                    this.appendStatementInput("STATEMENTS")
                        .setCheck(null)
                        .appendField("    ");
                    this.appendDummyInput()
                        .appendField("}");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(330);
                    this.setInputsInline(true);
                    this.setTooltip("Jika kondisi benar, jalankan blok perintah");
                }
            };

            // If-else statement
            Blockly.Blocks['cpp_if_else'] = {
                init: function() {
                    this.appendValueInput("CONDITION")
                        .setCheck("Boolean")
                        .appendField("ü§î if (");
                    this.appendDummyInput()
                        .appendField(") {");
                    this.appendStatementInput("IF_STATEMENTS")
                        .setCheck(null)
                        .appendField("    ");
                    this.appendDummyInput()
                        .appendField("} else {");
                    this.appendStatementInput("ELSE_STATEMENTS")
                        .setCheck(null)
                        .appendField("    ");
                    this.appendDummyInput()
                        .appendField("}");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(330);
                    this.setInputsInline(true);
                    this.setTooltip("Jika kondisi TRUE, jalankan blok IF. Jika FALSE, jalankan blok ELSE.");
                }
            };

            // For loop
            Blockly.Blocks['cpp_for'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üîÑ for (int")
                        .appendField(new Blockly.FieldTextInput("i"), "VAR")
                        .appendField("=")
                        .appendField(new Blockly.FieldNumber(1), "START")
                        .appendField(";")
                        .appendField(new Blockly.FieldTextInput("i"), "VAR2")
                        .appendField(new Blockly.FieldDropdown([
                            ["<=", "<="],
                            ["<", "<"],
                            [">=", ">="],
                            [">", ">"],
                            ["==", "=="],
                            ["!=", "!="]
                        ]), "CONDITION")
                        .appendField(new Blockly.FieldNumber(10), "END")
                        .appendField(";")
                        .appendField(new Blockly.FieldTextInput("i"), "VAR3")
                        .appendField(new Blockly.FieldDropdown([
                            ["++", "++"],
                            ["--", "--"],
                            ["+=", "+="],
                            ["-=", "-="]
                        ]), "INCREMENT")
                        .appendField(") {");
                    this.appendStatementInput("STATEMENTS")
                        .setCheck(null)
                        .appendField("    ");
                    this.appendDummyInput()
                        .appendField("}");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(180);
                    this.setTooltip("Pengulangan dengan berbagai kondisi dan increment");
                }
            };

            // While loop
            Blockly.Blocks['cpp_while'] = {
                init: function() {
                    this.appendValueInput("CONDITION")
                        .setCheck("Boolean")
                        .appendField("üîÑ while (");
                    this.appendDummyInput()
                        .appendField(") {");
                    this.appendStatementInput("STATEMENTS")
                        .setCheck(null)
                        .appendField("    ");
                    this.appendDummyInput()
                        .appendField("}");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(180);
                    this.setInputsInline(true);
                    this.setTooltip("Pengulangan selama kondisi benar");
                }
            };

            // Comment block
            Blockly.Blocks['cpp_comment'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("üí¨ //")
                        .appendField(new Blockly.FieldTextInput("komentar"), "TEXT");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(90);
                    this.setTooltip("Komentar - tidak dijalankan, hanya untuk catatan");
                }
            };
        }

        // Custom C++ Code Generator
        function createCppGenerator() {
            const generator = {
                ORDER_ATOMIC: 0,
                ORDER_NONE: 99,
                
                // Helper methods
                valueToCode: function(block, name, order) {
                    const targetBlock = block.getInputTargetBlock(name);
                    if (!targetBlock) return '';
                    
                    const func = this[targetBlock.type];
                    if (func) {
                        const result = func.call(this, targetBlock);
                        return Array.isArray(result) ? result[0] : result;
                    }
                    return '';
                },
                
                statementToCode: function(block, name) {
                    let code = '';
                    let targetBlock = block.getInputTargetBlock(name);
                    
                    while (targetBlock) {
                        const func = this[targetBlock.type];
                        if (func) {
                            const result = func.call(this, targetBlock);
                            code += Array.isArray(result) ? result[0] : result;
                        }
                        targetBlock = targetBlock.getNextBlock();
                    }
                    
                    return code;
                },
                
                blockToCode: function(block) {
                    const func = this[block.type];
                    if (func) {
                        const result = func.call(this, block);
                        return Array.isArray(result) ? result[0] : result;
                    }
                    return '';
                }
            };
            
            // Block generators
            generator['cpp_include'] = function(block) {
                const library = block.getFieldValue('LIBRARY');
                return `#include <${library}>\n`;
            };

            generator['cpp_namespace'] = function(block) {
                return 'using namespace std;\n';
            };

            generator['cpp_main'] = function(block) {
                const statements = this.statementToCode(block, 'STATEMENTS');
                return `int main() {\n${statements}    return 0;\n}\n`;
            };

            generator['cpp_cout'] = function(block) {
                const value = this.valueToCode(block, 'VALUE', this.ORDER_ATOMIC) || '""';
                const useEndl = block.getFieldValue('ENDL') === 'TRUE';
                const endlPart = useEndl ? ' << endl' : '';
                return `    cout << ${value}${endlPart};\n`;
            };

            generator['cpp_cin'] = function(block) {
                const variable = block.getFieldValue('VAR');
                return `    cin >> ${variable};\n`;
            };

            generator['cpp_declare_var'] = function(block) {
                const type = block.getFieldValue('TYPE');
                const name = block.getFieldValue('NAME');
                const value = this.valueToCode(block, 'VALUE', this.ORDER_ATOMIC) || '0';
                return `    ${type} ${name} = ${value};\n`;
            };

            generator['cpp_set_var'] = function(block) {
                const variable = block.getFieldValue('VAR');
                const value = this.valueToCode(block, 'VALUE', this.ORDER_ATOMIC) || '0';
                return `    ${variable} = ${value};\n`;
            };

            generator['cpp_get_var'] = function(block) {
                const variable = block.getFieldValue('VAR');
                return [variable, this.ORDER_ATOMIC];
            };

            generator['cpp_text'] = function(block) {
                const text = block.getFieldValue('TEXT');
                return [`"${text}"`, this.ORDER_ATOMIC];
            };

            generator['cpp_number'] = function(block) {
                const number = block.getFieldValue('NUM');
                return [number.toString(), this.ORDER_ATOMIC];
            };

            generator['cpp_boolean'] = function(block) {
                const bool = block.getFieldValue('BOOL');
                return [bool, this.ORDER_ATOMIC];
            };

            generator['cpp_math'] = function(block) {
                const a = this.valueToCode(block, 'A', this.ORDER_ATOMIC) || '0';
                const op = block.getFieldValue('OP');
                const b = this.valueToCode(block, 'B', this.ORDER_ATOMIC) || '0';
                return [`(${a} ${op} ${b})`, this.ORDER_ATOMIC];
            };

            generator['cpp_compare'] = function(block) {
                const a = this.valueToCode(block, 'A', this.ORDER_ATOMIC) || '0';
                const op = block.getFieldValue('OP');
                const b = this.valueToCode(block, 'B', this.ORDER_ATOMIC) || '0';
                return [`(${a} ${op} ${b})`, this.ORDER_ATOMIC];
            };

            generator['cpp_stream'] = function(block) {
                const left = this.valueToCode(block, 'LEFT', this.ORDER_ATOMIC) || 'cout';
                const op = block.getFieldValue('OP');
                const right = this.valueToCode(block, 'RIGHT', this.ORDER_ATOMIC) || '""';
                return [`${left} ${op} ${right}`, this.ORDER_ATOMIC];
            };

            generator['cpp_logical'] = function(block) {
                const a = this.valueToCode(block, 'A', this.ORDER_ATOMIC) || 'true';
                const op = block.getFieldValue('OP');
                const b = this.valueToCode(block, 'B', this.ORDER_ATOMIC) || 'true';
                return [`(${a} ${op} ${b})`, this.ORDER_ATOMIC];
            };

            generator['cpp_not'] = function(block) {
                const value = this.valueToCode(block, 'VALUE', this.ORDER_ATOMIC) || 'true';
                return [`!(${value})`, this.ORDER_ATOMIC];
            };

            generator['cpp_if'] = function(block) {
                const condition = this.valueToCode(block, 'CONDITION', this.ORDER_ATOMIC) || 'true';
                const statements = this.statementToCode(block, 'STATEMENTS');
                return `    if (${condition}) {\n${statements}    }\n`;
            };

            generator['cpp_if_else'] = function(block) {
                const condition = this.valueToCode(block, 'CONDITION', this.ORDER_ATOMIC) || 'true';
                const ifStatements = this.statementToCode(block, 'IF_STATEMENTS');
                const elseStatements = this.statementToCode(block, 'ELSE_STATEMENTS');
                return `    if (${condition}) {\n${ifStatements}    }\n    else {\n${elseStatements}    }\n`;
            };

            generator['cpp_for'] = function(block) {
                const variable = block.getFieldValue('VAR');
                const start = block.getFieldValue('START');
                const condition = block.getFieldValue('CONDITION');
                const end = block.getFieldValue('END');
                const increment = block.getFieldValue('INCREMENT');
                const statements = this.statementToCode(block, 'STATEMENTS');
                
                let incrementPart = '';
                if (increment === '++' || increment === '--') {
                    incrementPart = `${variable}${increment}`;
                } else {
                    incrementPart = `${variable} ${increment} 1`;
                }
                
                return `    for (int ${variable} = ${start}; ${variable} ${condition} ${end}; ${incrementPart}) {\n${statements}    }\n`;
            };

            generator['cpp_while'] = function(block) {
                const condition = this.valueToCode(block, 'CONDITION', this.ORDER_ATOMIC) || 'true';
                const statements = this.statementToCode(block, 'STATEMENTS');
                return `    while (${condition}) {\n${statements}    }\n`;
            };

            generator['cpp_comment'] = function(block) {
                const text = block.getFieldValue('TEXT');
                return `    // ${text}\n`;
            };
            
            return generator;
        }

        // Input handling functions
        function showInputModal(prompt, variableName) {
            return new Promise((resolve) => {
                const modal = document.getElementById('inputModal');
                const promptElement = document.getElementById('inputPrompt');
                const inputElement = document.getElementById('userInput');
                
                promptElement.textContent = prompt || `Masukkan nilai untuk variabel "${variableName}":`;
                inputElement.value = '';
                inputElement.focus();
                
                modal.classList.remove('hidden');
                
                const submitHandler = () => {
                    const value = inputElement.value.trim();
                    modal.classList.add('hidden');
                    resolve(value || '0');
                    cleanup();
                };
                
                const cancelHandler = () => {
                    modal.classList.add('hidden');
                    resolve('0');
                    cleanup();
                };
                
                const keyHandler = (e) => {
                    if (e.key === 'Enter') {
                        submitHandler();
                    } else if (e.key === 'Escape') {
                        cancelHandler();
                    }
                };
                
                const cleanup = () => {
                    document.getElementById('submitInput').removeEventListener('click', submitHandler);
                    document.getElementById('cancelInput').removeEventListener('click', cancelHandler);
                    inputElement.removeEventListener('keydown', keyHandler);
                };
                
                document.getElementById('submitInput').addEventListener('click', submitHandler);
                document.getElementById('cancelInput').addEventListener('click', cancelHandler);
                inputElement.addEventListener('keydown', keyHandler);
            });
        }

        // Initialize workspace
        function initWorkspace() {
            defineBlocks();
            
            // Create and store the generator
            window.cppGenerator = createCppGenerator();

            workspace = Blockly.inject('workspace', {
                toolbox: null,
                grid: {
                    spacing: 20,
                    length: 3,
                    colour: '#ccc',
                    snap: true
                },
                zoom: {
                    controls: true,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                },
                trashcan: true
            });
        }

        // Add block to workspace
        function addBlockToWorkspace(blockType) {
            const block = workspace.newBlock(blockType);
            block.initSvg();
            block.render();
            
            // Position blocks in a simple way
            const existingBlocks = workspace.getAllBlocks();
            
            if (existingBlocks.length === 1) {
                // First block - center it
                block.moveBy(100, 100);
            } else {
                // Find the bottom-most block position
                let maxY = 0;
                let maxX = 100;
                
                for (let existingBlock of existingBlocks) {
                    if (existingBlock !== block) {
                        const pos = existingBlock.getRelativeToSurfaceXY();
                        const height = existingBlock.getHeightWidth().height;
                        const bottomY = pos.y + height;
                        
                        if (bottomY > maxY) {
                            maxY = bottomY;
                            maxX = pos.x;
                        }
                    }
                }
                
                // Position new block below the bottom-most block
                const newY = maxY + 20; // 20px gap
                block.moveBy(maxX, newY);
            }
            
            return block;
        }

        // Generate and run C++ code
        async function generateAndRunCode() {
            try {
                const blocks = workspace.getAllBlocks();
                if (blocks.length === 0) {
                    document.getElementById('generatedCode').textContent = 'No blocks in workspace. Please add some blocks first.';
                    document.getElementById('programOutput').textContent = 'No code to execute.';
                    document.getElementById('codeModal').classList.remove('hidden');
                    return;
                }

                // Make sure generator is available
                if (!window.cppGenerator) {
                    document.getElementById('generatedCode').textContent = 'Code generator not ready. Please try again.';
                    document.getElementById('programOutput').textContent = 'Generator error.';
                    document.getElementById('codeModal').classList.remove('hidden');
                    return;
                }

                // Show loading state
                document.getElementById('programOutput').textContent = 'Compiling and running C++ code...\nPlease wait...';
                document.getElementById('codeModal').classList.remove('hidden');

                // Generate code from blocks - process connected blocks in sequence
                let code = '';
                const topBlocks = workspace.getTopBlocks();
                
                for (let topBlock of topBlocks) {
                    let currentBlock = topBlock;
                    
                    // Follow the chain of connected blocks
                    while (currentBlock) {
                        const blockCode = window.cppGenerator.blockToCode(currentBlock);
                        if (blockCode) {
                            code += blockCode;
                        }
                        
                        // Move to next connected block
                        currentBlock = currentBlock.getNextBlock();
                    }
                }
                
                document.getElementById('generatedCode').textContent = code || 'No code generated from blocks';
                
                // Reset input handling
                inputQueue = [];
                currentInputIndex = 0;
                programVariables = {};
                
                // Execute C++ code with interactive input
                let output = await executeCppCodeWithInput(code);
                
                if (!output) {
                    output = 'Program compiled successfully!\n(No output statements found)';
                }
                
                document.getElementById('programOutput').textContent = output;
            } catch (error) {
                console.error('Error generating code:', error);
                document.getElementById('generatedCode').textContent = 'Error generating code: ' + error.message;
                document.getElementById('programOutput').textContent = 'Error: ' + error.message;
                document.getElementById('codeModal').classList.remove('hidden');
            }
        }

        // Real C++ code execution using JSCPP
        let jscppReady = false;
        
        // Initialize JSCPP module
        function initializeJSCPP() {
            const modeIndicator = document.getElementById('executionMode');
            
            try {
                if (typeof JSCPP !== 'undefined') {
                    jscppReady = true;
                    console.log('JSCPP library loaded successfully');
                    
                    modeIndicator.textContent = 'Mode: Interactive C++ Execution';
                    modeIndicator.className = 'text-xs px-2 py-1 rounded bg-green-100 text-green-700';
                } else {
                    console.warn('JSCPP not available, falling back to simulation');
                    modeIndicator.textContent = 'Mode: Interactive Simulation';
                    modeIndicator.className = 'text-xs px-2 py-1 rounded bg-orange-100 text-orange-700';
                }
            } catch (error) {
                console.warn('Failed to initialize JSCPP:', error);
                console.log('Falling back to simulation mode');
                
                modeIndicator.textContent = 'Mode: Interactive Simulation';
                modeIndicator.className = 'text-xs px-2 py-1 rounded bg-red-100 text-red-700';
            }
        }
        
        // Execute C++ code with interactive input support
        async function executeCppCodeWithInput(code) {
            // First, collect all cin operations to prepare input prompts
            const cinMatches = code.match(/cin\s*>>\s*(\w+);/g);
            if (cinMatches) {
                inputQueue = cinMatches.map(match => {
                    const varMatch = match.match(/cin\s*>>\s*(\w+);/);
                    return varMatch ? varMatch[1] : 'variable';
                });
            }
            
            if (jscppReady && typeof JSCPP !== 'undefined') {
                try {
                    return await executeWithJSCPP(code);
                } catch (error) {
                    return `JSCPP Error: ${error.message || error}\n\nFalling back to simulation...`;
                }
            } else {
                return await simulateCppExecutionWithInput(code);
            }
        }
        
        // Execute with JSCPP (with input support)
        async function executeWithJSCPP(code) {
            let output = '';
            let inputIndex = 0;
            
            const config = {
                stdio: {
                    write: function(s) {
                        output += s;
                    },
                    read: async function() {
                        if (inputIndex < inputQueue.length) {
                            const variableName = inputQueue[inputIndex];
                            const userInput = await showInputModal(
                                `Program meminta input untuk variabel "${variableName}":`,
                                variableName
                            );
                            inputIndex++;
                            return userInput + '\n';
                        }
                        return '0\n';
                    }
                }
            };
            
            try {
                const exitCode = JSCPP.run(code, '', config);
                return output || `Program executed successfully (Exit code: ${exitCode})\n(No output statements found)`;
            } catch (error) {
                throw error;
            }
        }
        
        // Enhanced simulation with interactive input
        async function simulateCppExecutionWithInput(code) {
            try {
                const lines = code.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#') && !line.startsWith('using') && line !== 'int main() {' && line !== 'return 0;' && line !== '}');
                const variables = {};
                let output = '';
                let inputIndex = 0;
                
                for (let line of lines) {
                    if (!line || line === '}' || line === '{') continue;
                    
                    // Variable declaration
                    const declareMatch = line.match(/^\s*(int|double|string|bool)\s+(\w+)\s*=\s*(.+);/);
                    if (declareMatch) {
                        const varName = declareMatch[2];
                        let value = declareMatch[3].trim();
                        
                        // Handle mathematical expressions
                        if (value.includes('(') && value.includes(')')) {
                            try {
                                value = value.replace(/[()]/g, '');
                                const parts = value.split(/[\+\-\*\/]/);
                                if (parts.length === 2) {
                                    const num1 = parseFloat(parts[0].trim()) || 0;
                                    const num2 = parseFloat(parts[1].trim()) || 0;
                                    const operator = value.match(/[\+\-\*\/]/)[0];
                                    
                                    switch (operator) {
                                        case '+': value = num1 + num2; break;
                                        case '-': value = num1 - num2; break;
                                        case '*': value = num1 * num2; break;
                                        case '/': value = num2 !== 0 ? num1 / num2 : 0; break;
                                    }
                                }
                            } catch (e) {
                                value = 0;
                            }
                        } else if (value.startsWith('"') && value.endsWith('"')) {
                            variables[varName] = value.slice(1, -1);
                            continue;
                        } else if (value === 'true') {
                            variables[varName] = true;
                            continue;
                        } else if (value === 'false') {
                            variables[varName] = false;
                            continue;
                        } else {
                            value = parseFloat(value) || 0;
                        }
                        
                        variables[varName] = value;
                        continue;
                    }
                    
                    // Input statement (cin)
                    const cinMatch = line.match(/cin\s*>>\s*(\w+);/);
                    if (cinMatch) {
                        const varName = cinMatch[1];
                        const userInput = await showInputModal(
                            `Masukkan nilai untuk variabel "${varName}":`,
                            varName
                        );
                        
                        // Try to parse as number, otherwise keep as string
                        const numValue = parseFloat(userInput);
                        if (!isNaN(numValue)) {
                            variables[varName] = numValue;
                        } else {
                            variables[varName] = userInput;
                        }
                        
                        output += `Input received: ${varName} = ${variables[varName]}\n`;
                        continue;
                    }
                    
                    // Variable assignment
                    const assignMatch = line.match(/^\s*(\w+)\s*=\s*(.+);/);
                    if (assignMatch && !line.includes('int ') && !line.includes('double ') && !line.includes('string ') && !line.includes('bool ')) {
                        const varName = assignMatch[1];
                        let value = assignMatch[2].trim();
                        
                        // Handle mathematical expressions with variables
                        if (value.includes('(') && value.includes(')')) {
                            try {
                                // Replace variables with their values
                                let expression = value.replace(/[()]/g, '');
                                for (let varKey in variables) {
                                    expression = expression.replace(new RegExp(`\\b${varKey}\\b`, 'g'), variables[varKey]);
                                }
                                
                                const parts = expression.split(/[\+\-\*\/\%]/);
                                if (parts.length === 2) {
                                    const num1 = parseFloat(parts[0].trim()) || 0;
                                    const num2 = parseFloat(parts[1].trim()) || 0;
                                    const operator = expression.match(/[\+\-\*\/\%]/)[0];
                                    
                                    switch (operator) {
                                        case '+': value = num1 + num2; break;
                                        case '-': value = num1 - num2; break;
                                        case '*': value = num1 * num2; break;
                                        case '/': value = num2 !== 0 ? num1 / num2 : 0; break;
                                        case '%': value = num2 !== 0 ? num1 % num2 : 0; break;
                                    }
                                }
                            } catch (e) {
                                value = 0;
                            }
                        } else if (value.startsWith('"') && value.endsWith('"')) {
                            variables[varName] = value.slice(1, -1);
                            continue;
                        } else if (value === 'true') {
                            variables[varName] = true;
                            continue;
                        } else if (value === 'false') {
                            variables[varName] = false;
                            continue;
                        } else if (variables[value] !== undefined) {
                            variables[varName] = variables[value];
                            continue;
                        } else {
                            value = parseFloat(value) || 0;
                        }
                        
                        variables[varName] = value;
                        continue;
                    }
                    
                    // Output statement
                    if (line.includes('cout <<')) {
                        const match = line.match(/cout << (.+);/);
                        if (match) {
                            let expression = match[1].trim();
                            let outputValue = '';
                            
                            if (expression.startsWith('"') && expression.endsWith('"')) {
                                outputValue = expression.slice(1, -1);
                            } else if (variables[expression] !== undefined) {
                                outputValue = variables[expression];
                            } else {
                                outputValue = expression;
                            }
                            
                            output += outputValue + '\n';
                        }
                        continue;
                    }
                    
                    // For loop (enhanced)
                    if (line.startsWith('for (')) {
                        const forMatch = line.match(/for \(int (\w+) = (\d+); \w+ ([<>=!]+) (\d+); \w+(\+\+|--|\+=|\-=)\)/);
                        if (forMatch) {
                            const varName = forMatch[1];
                            const start = parseInt(forMatch[2]);
                            const condition = forMatch[3];
                            const end = parseInt(forMatch[4]);
                            const increment = forMatch[5];
                            
                            let current = start;
                            let iterations = 0;
                            const maxIterations = 1000; // Safety limit
                            
                            while (iterations < maxIterations) {
                                // Check condition
                                let conditionMet = false;
                                switch (condition) {
                                    case '<=': conditionMet = current <= end; break;
                                    case '<': conditionMet = current < end; break;
                                    case '>=': conditionMet = current >= end; break;
                                    case '>': conditionMet = current > end; break;
                                    case '==': conditionMet = current == end; break;
                                    case '!=': conditionMet = current != end; break;
                                }
                                
                                if (!conditionMet) break;
                                
                                variables[varName] = current;
                                
                                // Increment
                                switch (increment) {
                                    case '++': current++; break;
                                    case '--': current--; break;
                                    case '+=': current += 1; break;
                                    case '-=': current -= 1; break;
                                }
                                
                                iterations++;
                            }
                            
                            output += `For loop completed: ${iterations} iterations\n`;
                        }
                        continue;
                    }
                    
                    // If statement (enhanced)
                    if (line.includes('if (')) {
                        const ifMatch = line.match(/if \((.+)\)/);
                        if (ifMatch) {
                            const condition = ifMatch[1].trim();
                            let conditionResult = false;
                            
                            // Enhanced condition evaluation
                            if (condition.includes('%')) {
                                // Handle modulo operations like "i % 2 == 0"
                                const moduloMatch = condition.match(/(\w+)\s*%\s*(\d+)\s*(==|!=|>|<|>=|<=)\s*(\d+)/);
                                if (moduloMatch) {
                                    const varName = moduloMatch[1];
                                    const divisor = parseInt(moduloMatch[2]);
                                    const operator = moduloMatch[3];
                                    const compareValue = parseInt(moduloMatch[4]);
                                    
                                    if (variables[varName] !== undefined) {
                                        const modResult = variables[varName] % divisor;
                                        switch (operator) {
                                            case '==': conditionResult = modResult == compareValue; break;
                                            case '!=': conditionResult = modResult != compareValue; break;
                                            case '>': conditionResult = modResult > compareValue; break;
                                            case '<': conditionResult = modResult < compareValue; break;
                                            case '>=': conditionResult = modResult >= compareValue; break;
                                            case '<=': conditionResult = modResult <= compareValue; break;
                                        }
                                    }
                                }
                            } else if (condition.includes('==')) {
                                const parts = condition.split('==').map(p => p.trim());
                                const left = variables[parts[0]] !== undefined ? variables[parts[0]] : parts[0];
                                const right = variables[parts[1]] !== undefined ? variables[parts[1]] : parts[1];
                                conditionResult = left == right;
                            } else if (condition.includes('>')) {
                                const parts = condition.split('>').map(p => p.trim());
                                const left = variables[parts[0]] !== undefined ? variables[parts[0]] : parseFloat(parts[0]);
                                const right = variables[parts[1]] !== undefined ? variables[parts[1]] : parseFloat(parts[1]);
                                conditionResult = left > right;
                            }
                            
                            output += `If condition (${condition}): ${conditionResult ? 'TRUE' : 'FALSE'}\n`;
                        }
                        continue;
                    }
                    
                    // Comment
                    if (line.startsWith('//')) {
                        continue;
                    }
                }
                
                return output || 'Program executed successfully!\n(No output statements found)';
            } catch (error) {
                return `Simulation Error: ${error.message}`;
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            initWorkspace();
            initializeJSCPP(); // Initialize JSCPP library

            // Add block button
            document.getElementById('addBlockBtn').addEventListener('click', function() {
                document.getElementById('blockModal').classList.remove('hidden');
            });

            // Close modal buttons
            document.getElementById('closeModal').addEventListener('click', function() {
                document.getElementById('blockModal').classList.add('hidden');
            });

            document.getElementById('closeTemplateModal').addEventListener('click', function() {
                document.getElementById('templateModal').classList.add('hidden');
            });

            document.getElementById('closeCodeModal').addEventListener('click', function() {
                document.getElementById('codeModal').classList.add('hidden');
            });

            // Template button
            document.getElementById('quickTemplateBtn').addEventListener('click', function() {
                document.getElementById('templateModal').classList.remove('hidden');
            });

            // Clear button
            document.getElementById('clearBtn').addEventListener('click', function() {
                if (confirm('Hapus semua blok? Tindakan ini tidak dapat dibatalkan.')) {
                    workspace.clear();
                }
            });

            // Run button
            document.getElementById('runBtn').addEventListener('click', generateAndRunCode);

            // Block selection
            document.querySelectorAll('.block-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const blockType = this.getAttribute('data-type');
                    let actualBlockType;
                    
                    // Map block types correctly
                    switch(blockType) {
                        case 'include':
                            actualBlockType = 'cpp_include';
                            break;
                        case 'namespace':
                            actualBlockType = 'cpp_namespace';
                            break;
                        case 'main':
                            actualBlockType = 'cpp_main';
                            break;
                        case 'cout':
                            actualBlockType = 'cpp_cout';
                            break;
                        case 'cin':
                            actualBlockType = 'cpp_cin';
                            break;
                        case 'declare_var':
                            actualBlockType = 'cpp_declare_var';
                            break;
                        case 'set_var':
                            actualBlockType = 'cpp_set_var';
                            break;
                        case 'get_var':
                            actualBlockType = 'cpp_get_var';
                            break;
                        case 'text':
                            actualBlockType = 'cpp_text';
                            break;
                        case 'number':
                            actualBlockType = 'cpp_number';
                            break;
                        case 'boolean':
                            actualBlockType = 'cpp_boolean';
                            break;
                        case 'math_op':
                            actualBlockType = 'cpp_math';
                            break;
                        case 'compare_op':
                            actualBlockType = 'cpp_compare';
                            break;
                        case 'logical_op':
                            actualBlockType = 'cpp_logical';
                            break;
                        case 'not_op':
                            actualBlockType = 'cpp_not';
                            break;
                        case 'stream':
                            actualBlockType = 'cpp_stream';
                            break;
                        case 'if':
                            actualBlockType = 'cpp_if';
                            break;
                        case 'if_else':
                            actualBlockType = 'cpp_if_else';
                            break;
                        case 'for_loop':
                            actualBlockType = 'cpp_for';
                            break;
                        case 'while_loop':
                            actualBlockType = 'cpp_while';
                            break;
                        case 'comment':
                            actualBlockType = 'cpp_comment';
                            break;
                        default:
                            actualBlockType = 'cpp_' + blockType;
                    }
                    
                    try {
                        addBlockToWorkspace(actualBlockType);
                        document.getElementById('blockModal').classList.add('hidden');
                    } catch (error) {
                        console.error('Error adding block:', error);
                        alert('Terjadi kesalahan saat menambahkan blok: ' + actualBlockType);
                    }
                });
            });

            // Template selection
            document.querySelectorAll('[data-template]').forEach(template => {
                template.addEventListener('click', function() {
                    const templateType = this.getAttribute('data-template');
                    createTemplate(templateType);
                    document.getElementById('templateModal').classList.add('hidden');
                });
            });

            // Close modals when clicking outside
            document.getElementById('blockModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.add('hidden');
                }
            });

            document.getElementById('templateModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.add('hidden');
                }
            });
        });

        // Create template programs
        function createTemplate(templateType) {
            workspace.clear();
            
            switch (templateType) {
                case 'hello-world':
                    createHelloWorldTemplate();
                    break;
                case 'calculator':
                    createCalculatorTemplate();
                    break;
                case 'loop-example':
                    createLoopExampleTemplate();
                    break;
            }
        }

        function createHelloWorldTemplate() {
            // Create include block
            const includeBlock = addBlockToWorkspace('cpp_include');
            includeBlock.setFieldValue('iostream', 'LIBRARY');
            
            // Create namespace block
            const namespaceBlock = addBlockToWorkspace('cpp_namespace');
            
            // Create main function block
            const mainBlock = addBlockToWorkspace('cpp_main');
            
            // Create cout block
            const coutBlock = addBlockToWorkspace('cpp_cout');
            
            // Create text block
            const textBlock = addBlockToWorkspace('cpp_text');
            textBlock.setFieldValue('Hello World!', 'TEXT');
            
            // Connect blocks
            includeBlock.nextConnection.connect(namespaceBlock.previousConnection);
            namespaceBlock.nextConnection.connect(mainBlock.previousConnection);
            
            // Connect cout inside main function
            const mainStatements = mainBlock.getInput('STATEMENTS');
            if (mainStatements && mainStatements.connection) {
                mainStatements.connection.connect(coutBlock.previousConnection);
            }
            
            // Connect text to cout
            const coutValue = coutBlock.getInput('VALUE');
            if (coutValue && coutValue.connection && textBlock.outputConnection) {
                coutValue.connection.connect(textBlock.outputConnection);
            }
        }

        function createCalculatorTemplate() {
            // Create basic structure
            const includeBlock = addBlockToWorkspace('cpp_include');
            includeBlock.setFieldValue('iostream', 'LIBRARY');
            
            const namespaceBlock = addBlockToWorkspace('cpp_namespace');
            const mainBlock = addBlockToWorkspace('cpp_main');
            
            // Create variable declarations
            const num1Block = addBlockToWorkspace('cpp_declare_var');
            num1Block.setFieldValue('double', 'TYPE');
            num1Block.setFieldValue('num1', 'NAME');
            const num1Value = addBlockToWorkspace('cpp_number');
            num1Value.setFieldValue(0, 'NUM');
            
            const num2Block = addBlockToWorkspace('cpp_declare_var');
            num2Block.setFieldValue('double', 'TYPE');
            num2Block.setFieldValue('num2', 'NAME');
            const num2Value = addBlockToWorkspace('cpp_number');
            num2Value.setFieldValue(0, 'NUM');
            
            const resultBlock = addBlockToWorkspace('cpp_declare_var');
            resultBlock.setFieldValue('double', 'TYPE');
            resultBlock.setFieldValue('result', 'NAME');
            const resultValue = addBlockToWorkspace('cpp_number');
            resultValue.setFieldValue(0, 'NUM');
            
            // Create input prompts
            const prompt1Block = addBlockToWorkspace('cpp_cout');
            const prompt1Text = addBlockToWorkspace('cpp_text');
            prompt1Text.setFieldValue('Masukkan angka pertama: ', 'TEXT');
            prompt1Block.setFieldValue('FALSE', 'ENDL');
            
            const input1Block = addBlockToWorkspace('cpp_cin');
            input1Block.setFieldValue('num1', 'VAR');
            
            const prompt2Block = addBlockToWorkspace('cpp_cout');
            const prompt2Text = addBlockToWorkspace('cpp_text');
            prompt2Text.setFieldValue('Masukkan angka kedua: ', 'TEXT');
            prompt2Block.setFieldValue('FALSE', 'ENDL');
            
            const input2Block = addBlockToWorkspace('cpp_cin');
            input2Block.setFieldValue('num2', 'VAR');
            
            // Create calculation
            const calcBlock = addBlockToWorkspace('cpp_set_var');
            calcBlock.setFieldValue('result', 'VAR');
            const mathBlock = addBlockToWorkspace('cpp_math');
            mathBlock.setFieldValue('+', 'OP');
            const var1Block = addBlockToWorkspace('cpp_get_var');
            var1Block.setFieldValue('num1', 'VAR');
            const var2Block = addBlockToWorkspace('cpp_get_var');
            var2Block.setFieldValue('num2', 'VAR');
            
            // Create output
            const outputBlock = addBlockToWorkspace('cpp_cout');
            const outputText = addBlockToWorkspace('cpp_text');
            outputText.setFieldValue('Hasil: ', 'TEXT');
            outputBlock.setFieldValue('FALSE', 'ENDL');
            
            const resultOutputBlock = addBlockToWorkspace('cpp_cout');
            const resultVar = addBlockToWorkspace('cpp_get_var');
            resultVar.setFieldValue('result', 'VAR');
            
            // Connect main structure
            includeBlock.nextConnection.connect(namespaceBlock.previousConnection);
            namespaceBlock.nextConnection.connect(mainBlock.previousConnection);
            
            // Connect all blocks inside main function
            const mainStatements = mainBlock.getInput('STATEMENTS');
            if (mainStatements && mainStatements.connection) {
                mainStatements.connection.connect(num1Block.previousConnection);
                num1Block.nextConnection.connect(num2Block.previousConnection);
                num2Block.nextConnection.connect(resultBlock.previousConnection);
                resultBlock.nextConnection.connect(prompt1Block.previousConnection);
                prompt1Block.nextConnection.connect(input1Block.previousConnection);
                input1Block.nextConnection.connect(prompt2Block.previousConnection);
                prompt2Block.nextConnection.connect(input2Block.previousConnection);
                input2Block.nextConnection.connect(calcBlock.previousConnection);
                calcBlock.nextConnection.connect(outputBlock.previousConnection);
                outputBlock.nextConnection.connect(resultOutputBlock.previousConnection);
            }
            
            // Connect values to variable declarations
            num1Block.getInput('VALUE').connection.connect(num1Value.outputConnection);
            num2Block.getInput('VALUE').connection.connect(num2Value.outputConnection);
            resultBlock.getInput('VALUE').connection.connect(resultValue.outputConnection);
            
            // Connect text to cout blocks
            prompt1Block.getInput('VALUE').connection.connect(prompt1Text.outputConnection);
            prompt2Block.getInput('VALUE').connection.connect(prompt2Text.outputConnection);
            outputBlock.getInput('VALUE').connection.connect(outputText.outputConnection);
            resultOutputBlock.getInput('VALUE').connection.connect(resultVar.outputConnection);
            
            // Connect math operation
            mathBlock.getInput('A').connection.connect(var1Block.outputConnection);
            mathBlock.getInput('B').connection.connect(var2Block.outputConnection);
            calcBlock.getInput('VALUE').connection.connect(mathBlock.outputConnection);
        }

        function createLoopExampleTemplate() {
            // Create basic structure
            const includeBlock = addBlockToWorkspace('cpp_include');
            includeBlock.setFieldValue('iostream', 'LIBRARY');
            
            const namespaceBlock = addBlockToWorkspace('cpp_namespace');
            const mainBlock = addBlockToWorkspace('cpp_main');
            
            // Create for loop
            const forBlock = addBlockToWorkspace('cpp_for');
            forBlock.setFieldValue('i', 'VAR');
            forBlock.setFieldValue('i', 'VAR2');
            forBlock.setFieldValue('i', 'VAR3');
            forBlock.setFieldValue(1, 'START');
            forBlock.setFieldValue('<=', 'CONDITION');
            forBlock.setFieldValue(10, 'END');
            forBlock.setFieldValue('++', 'INCREMENT');
            
            // Create if statement inside loop to check even/odd
            const ifBlock = addBlockToWorkspace('cpp_if_else');
            const compareBlock = addBlockToWorkspace('cpp_compare');
            compareBlock.setFieldValue('==', 'OP');
            
            // Math operation for modulo (i % 2)
            const moduloBlock = addBlockToWorkspace('cpp_math');
            moduloBlock.setFieldValue('%', 'OP');
            const iVarBlock = addBlockToWorkspace('cpp_get_var');
            iVarBlock.setFieldValue('i', 'VAR');
            const twoBlock = addBlockToWorkspace('cpp_number');
            twoBlock.setFieldValue(2, 'NUM');
            const zeroBlock = addBlockToWorkspace('cpp_number');
            zeroBlock.setFieldValue(0, 'NUM');
            
            // Output for even numbers
            const evenCoutBlock = addBlockToWorkspace('cpp_cout');
            const evenVarBlock = addBlockToWorkspace('cpp_get_var');
            evenVarBlock.setFieldValue('i', 'VAR');
            
            const evenTextBlock = addBlockToWorkspace('cpp_cout');
            const evenText = addBlockToWorkspace('cpp_text');
            evenText.setFieldValue(' adalah bilangan genap', 'TEXT');
            
            // Output for odd numbers
            const oddCoutBlock = addBlockToWorkspace('cpp_cout');
            const oddVarBlock = addBlockToWorkspace('cpp_get_var');
            oddVarBlock.setFieldValue('i', 'VAR');
            
            const oddTextBlock = addBlockToWorkspace('cpp_cout');
            const oddText = addBlockToWorkspace('cpp_text');
            oddText.setFieldValue(' adalah bilangan ganjil', 'TEXT');
            
            // Connect main structure
            includeBlock.nextConnection.connect(namespaceBlock.previousConnection);
            namespaceBlock.nextConnection.connect(mainBlock.previousConnection);
            
            // Connect loop inside main
            const mainStatements = mainBlock.getInput('STATEMENTS');
            if (mainStatements && mainStatements.connection) {
                mainStatements.connection.connect(forBlock.previousConnection);
            }
            
            // Connect if statement inside loop
            const forStatements = forBlock.getInput('STATEMENTS');
            if (forStatements && forStatements.connection) {
                forStatements.connection.connect(ifBlock.previousConnection);
            }
            
            // Connect condition for if statement (i % 2 == 0)
            moduloBlock.getInput('A').connection.connect(iVarBlock.outputConnection);
            moduloBlock.getInput('B').connection.connect(twoBlock.outputConnection);
            compareBlock.getInput('A').connection.connect(moduloBlock.outputConnection);
            compareBlock.getInput('B').connection.connect(zeroBlock.outputConnection);
            ifBlock.getInput('CONDITION').connection.connect(compareBlock.outputConnection);
            
            // Connect even number output (IF branch)
            const ifStatements = ifBlock.getInput('IF_STATEMENTS');
            if (ifStatements && ifStatements.connection) {
                ifStatements.connection.connect(evenCoutBlock.previousConnection);
                evenCoutBlock.nextConnection.connect(evenTextBlock.previousConnection);
            }
            
            // Connect odd number output (ELSE branch)
            const elseStatements = ifBlock.getInput('ELSE_STATEMENTS');
            if (elseStatements && elseStatements.connection) {
                elseStatements.connection.connect(oddCoutBlock.previousConnection);
                oddCoutBlock.nextConnection.connect(oddTextBlock.previousConnection);
            }
            
            // Connect values to cout blocks
            evenCoutBlock.getInput('VALUE').connection.connect(evenVarBlock.outputConnection);
            evenCoutBlock.setFieldValue('FALSE', 'ENDL');
            evenTextBlock.getInput('VALUE').connection.connect(evenText.outputConnection);
            
            oddCoutBlock.getInput('VALUE').connection.connect(oddVarBlock.outputConnection);
            oddCoutBlock.setFieldValue('FALSE', 'ENDL');
            oddTextBlock.getInput('VALUE').connection.connect(oddText.outputConnection);
        }
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'97b0853af105fd96',t:'MTc1NzE4ODQ4OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
